<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ProcessMemoryUtilities</name>
    </assembly>
    <members>
        <member name="T:ProcessMemoryUtilities.Extensions.IntPtrExtensions">
            <summary>
            Provides extension methods to validate and calculate with IntPtr.
            </summary>
        </member>
        <member name="M:ProcessMemoryUtilities.Extensions.IntPtrExtensions.Add(System.IntPtr,System.IntPtr)">
            <summary>
            Adds the value of the second pointer to the value of the first pointer.
            </summary>
            <param name="left">The pointer to add the second pointer to.</param>
            <param name="right">The pointer to add.</param>
            <returns>A new pointer that reflects the addition of two pointers.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Extensions.IntPtrExtensions.Divide(System.IntPtr,System.IntPtr)">
            <summary>
            Divides the value of the first pointer by the value of the second pointer.
            </summary>
            <param name="left">The dividend.</param>
            <param name="right">The divisor.</param>
            <returns>A new pointer that reflects the division of two pointers.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Extensions.IntPtrExtensions.GetValue(System.IntPtr)">
            <summary>
            Retrieves the value of a pointer.
            </summary>
            <param name="ptr">The pointer to retrieve its value from.</param>
            <returns>An unsigned long representing the value of the supplied pointer.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Extensions.IntPtrExtensions.IsAligned(System.IntPtr)">
            <summary>
            Determines whether a pointer or offset is aligned.
            </summary>
            <param name="ptr">The pointer or offset to check.</param>
            <returns><see langword="true"/> if the supplied pointer or offset is aligned; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Extensions.IntPtrExtensions.IsNotZero(System.IntPtr)">
            <summary>
            Determines whether the given pointer is not zero.
            </summary>
            <param name="ptr">The pointer or offset to check.</param>
            <returns><see langword="true"/> if the supplied pointer or offset is not zero; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Extensions.IntPtrExtensions.IsValid(System.IntPtr)">
            <summary>
            Determines whether the given pointer is a valid address on windows.
            </summary>
            <param name="ptr">The pointer to check.</param>
            <returns><see langword="true"/> if the supplied pointer represents a valid address; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Extensions.IntPtrExtensions.IsZero(System.IntPtr)">
            <summary>
            Determines whether a pointer or offset is zero.
            </summary>
            <param name="ptr">The pointer or offset to check.</param>
            <returns><see langword="true"/> if the supplied pointer is zero; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Extensions.IntPtrExtensions.Multiply(System.IntPtr,System.IntPtr)">
            <summary>
            Multiplies the value of the first pointer by the value of the second pointer.
            </summary>
            <param name="left">The first pointer.</param>
            <param name="right">The second pointer.</param>
            <returns>A new pointer that reflects the multiplication of two pointers.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Extensions.IntPtrExtensions.Subtract(System.IntPtr,System.IntPtr)">
            <summary>
            Reduces the value of the first pointer by the value of the second pointer.
            </summary>
            <param name="left">The first pointer.</param>
            <param name="right">The second pointer.</param>
            <returns>A new pointer that reflects the subtraction of two pointers.</returns>
        </member>
        <member name="T:ProcessMemoryUtilities.Memory.ProcessMemory">
            <summary>
            Provides methods to allocate, protect, free, read, write and execute memory in a remote process.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.ProcessMemory.PROCESS_ALLOCATE_ACCESS">
            <summary>
            A constant to use with OpenProcess when requiring access to allocate memory.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.ProcessMemory.PROCESS_EXECUTE_ACCESS">
            <summary>
            A constant to use with OpenProcess when requiring access to execute memory.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.ProcessMemory.PROCESS_INFORMATION_ACCESS">
            <summary>
            A constant to use with OpenProcess when requiring access to informations about the process and its memory.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.ProcessMemory.PROCESS_READ_ACCESS">
            <summary>
            A constant to be use with OpenProcess when requiring access to read memory.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.ProcessMemory.PROCESS_READ_WRITE_ACCESS">
            <summary>
            A constant to be use with OpenProcess when requiring access to read and write memory.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.ProcessMemory.PROCESS_WRITE_ACCESS">
            <summary>
            A constant to use with OpenProcess when requiring access to write memory.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.ProcessMemory.WAIT_TIMEOUT_INFINITE">
            <summary>
            A constant to use with WaitForSingleObject to wait for an infinite amount of time.
            </summary>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.ProcessMemory.CloseHandle(System.IntPtr)">
            <summary>
            Closes an open object handle.
            </summary>
            <param name="handle">A valid handle to an open object.</param>
            <returns><see langword="true"/> if the function succeeds; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.ProcessMemory.CreateRemoteThreadEx(System.IntPtr,System.IntPtr)">
            <summary>
            Creates a thread that runs in the virtual address space of another process and optionally specifies extended attributes such as processor
            group affinity.
            </summary>
            <param name="handle">
            A handle to the process in which the thread is to be created. The handle must have the PROCESS_CREATE_THREAD, PROCESS_QUERY_INFORMATION,
            PROCESS_VM_OPERATION, PROCESS_VM_WRITE, and PROCESS_VM_READ access rights.
            </param>
            <param name="startAddress">
            A pointer to the application-defined function of type LPTHREAD_START_ROUTINE to be executed by the thread and represents the starting
            address of the thread in the remote process. The function must exist in the remote process.
            </param>
            <returns>
            If the function succeeds, the return value is a handle to the new thread. If the function fails, the return value is NULL.
            </returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.ProcessMemory.CreateRemoteThreadEx(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Creates a thread that runs in the virtual address space of another process and optionally specifies extended attributes such as processor
            group affinity.
            </summary>
            <param name="handle">
            A handle to the process in which the thread is to be created. The handle must have the PROCESS_CREATE_THREAD, PROCESS_QUERY_INFORMATION,
            PROCESS_VM_OPERATION, PROCESS_VM_WRITE, and PROCESS_VM_READ access rights.
            </param>
            <param name="startAddress">
            A pointer to the application-defined function of type LPTHREAD_START_ROUTINE to be executed by the thread and represents the starting
            address of the thread in the remote process. The function must exist in the remote process.
            </param>
            <param name="parameter">
            A pointer to a variable to be passed to the thread function pointed to by lpStartAddress. This parameter can be NULL.
            </param>
            <returns>
            If the function succeeds, the return value is a handle to the new thread. If the function fails, the return value is NULL.
            </returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.ProcessMemory.CreateRemoteThreadEx(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,ProcessMemoryUtilities.Memory.ThreadCreationFlags,System.IntPtr)">
            <summary>
            Creates a thread that runs in the virtual address space of another process and optionally specifies extended attributes such as processor
            group affinity.
            </summary>
            <param name="handle">
            A handle to the process in which the thread is to be created. The handle must have the PROCESS_CREATE_THREAD, PROCESS_QUERY_INFORMATION,
            PROCESS_VM_OPERATION, PROCESS_VM_WRITE, and PROCESS_VM_READ access rights.
            </param>
            <param name="threadAttributes">
            A pointer to a SECURITY_ATTRIBUTES structure that specifies a security descriptor for the new thread and determines whether child processes
            can inherit the returned handle. If lpThreadAttributes is NULL, the thread gets a default security descriptor and the handle cannot be
            inherited. The access control lists (ACL) in the default security descriptor for a thread come from the primary token of the creator.
            </param>
            <param name="stackSize">
            The initial size of the stack, in bytes. The system rounds this value to the nearest page. If this parameter is 0 (zero), the new thread
            uses the default size for the executable. For more information, see Thread Stack Size.
            </param>
            <param name="startAddress">
            A pointer to the application-defined function of type LPTHREAD_START_ROUTINE to be executed by the thread and represents the starting
            address of the thread in the remote process. The function must exist in the remote process.
            </param>
            <param name="parameter">
            A pointer to a variable to be passed to the thread function pointed to by lpStartAddress. This parameter can be NULL.
            </param>
            <param name="creationFlags">The flags that control the creation of the thread.</param>
            <param name="attributeList">
            An attribute list that contains additional parameters for the new thread. This list is created by the InitializeProcThreadAttributeList
            function.
            </param>
            <returns>
            If the function succeeds, the return value is a handle to the new thread. If the function fails, the return value is NULL.
            </returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.ProcessMemory.CreateRemoteThreadEx(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,ProcessMemoryUtilities.Memory.ThreadCreationFlags,System.IntPtr,System.UInt32@)">
            <summary>
            Creates a thread that runs in the virtual address space of another process and optionally specifies extended attributes such as processor
            group affinity.
            </summary>
            <param name="handle">
            A handle to the process in which the thread is to be created. The handle must have the PROCESS_CREATE_THREAD, PROCESS_QUERY_INFORMATION,
            PROCESS_VM_OPERATION, PROCESS_VM_WRITE, and PROCESS_VM_READ access rights.
            </param>
            <param name="threadAttributes">
            A pointer to a SECURITY_ATTRIBUTES structure that specifies a security descriptor for the new thread and determines whether child processes
            can inherit the returned handle. If lpThreadAttributes is NULL, the thread gets a default security descriptor and the handle cannot be
            inherited. The access control lists (ACL) in the default security descriptor for a thread come from the primary token of the creator.
            </param>
            <param name="stackSize">
            The initial size of the stack, in bytes. The system rounds this value to the nearest page. If this parameter is 0 (zero), the new thread
            uses the default size for the executable. For more information, see Thread Stack Size.
            </param>
            <param name="startAddress">
            A pointer to the application-defined function of type LPTHREAD_START_ROUTINE to be executed by the thread and represents the starting
            address of the thread in the remote process. The function must exist in the remote process.
            </param>
            <param name="parameter">
            A pointer to a variable to be passed to the thread function pointed to by lpStartAddress. This parameter can be NULL.
            </param>
            <param name="creationFlags">The flags that control the creation of the thread.</param>
            <param name="attributeList">
            An attribute list that contains additional parameters for the new thread. This list is created by the InitializeProcThreadAttributeList
            function.
            </param>
            <param name="threadId">A variable that receives the thread identifier.</param>
            <returns>
            If the function succeeds, the return value is a handle to the new thread. If the function fails, the return value is NULL.
            </returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.ProcessMemory.OpenProcess(ProcessMemoryUtilities.Memory.ProcessAccessFlags,System.Int32)">
            <summary>
            Opens an existing local process object.
            </summary>
            <param name="desiredAccess">
            The access to the process object. This access right is checked against the security descriptor for the process. This parameter can be one
            or more of the process access rights.
            </param>
            <param name="processId">The identifier of the local process to be opened.</param>
            <returns>
            If the function succeeds, the return value is an open handle to the specified process. If the function fails, the return value is NULL.
            </returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.ProcessMemory.OpenProcess(ProcessMemoryUtilities.Memory.ProcessAccessFlags,System.Boolean,System.Int32)">
            <summary>
            Opens an existing local process object.
            </summary>
            <param name="desiredAccess">
            The access to the process object. This access right is checked against the security descriptor for the process. This parameter can be one
            or more of the process access rights.
            </param>
            <param name="inheritHandle">
            If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.
            </param>
            <param name="processId">The identifier of the local process to be opened.</param>
            <returns>
            If the function succeeds, the return value is an open handle to the specified process. If the function fails, the return value is NULL.
            </returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.ProcessMemory.ReadProcessMemory(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Reads data from an area of memory in a specified process. The entire area to be read must be accessible or the operation fails.
            </summary>
            <param name="handle">
            A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.
            </param>
            <param name="baseAddress">
            A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all
            data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.
            </param>
            <param name="buffer">A pointer to a buffer that receives the contents from the address space of the specified process.</param>
            <param name="size">The number of bytes to be read from the specified process.</param>
            <returns><see langword="true"/> if the function succeeds; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.ProcessMemory.ReadProcessMemory(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr@)">
            <summary>
            Reads data from an area of memory in a specified process. The entire area to be read must be accessible or the operation fails.
            </summary>
            <param name="handle">
            A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.
            </param>
            <param name="baseAddress">
            A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all
            data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.
            </param>
            <param name="buffer">A pointer to a buffer that receives the contents from the address space of the specified process.</param>
            <param name="size">The number of bytes to be read from the specified process.</param>
            <param name="numberOfBytesRead">A pointer to a variable that receives the number of bytes transferred into the specified buffer.</param>
            <returns><see langword="true"/> if the function succeeds; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.ProcessMemory.ReadProcessMemory``1(System.IntPtr,System.IntPtr,``0@)">
            <summary>
            Reads data from an area of memory in a specified process. The entire area to be read must be accessible or the operation fails.
            </summary>
            <typeparam name="T">The type of the data to return.</typeparam>
            <param name="handle">
            A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.
            </param>
            <param name="baseAddress">
            A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all
            data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.
            </param>
            <param name="buffer">A pointer to a buffer that receives the contents from the address space of the specified process.</param>
            <returns><see langword="true"/> if the function succeeds; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.ProcessMemory.ReadProcessMemory``1(System.IntPtr,System.IntPtr,``0@,System.IntPtr@)">
            <summary>
            Reads data from an area of memory in a specified process. The entire area to be read must be accessible or the operation fails.
            </summary>
            <typeparam name="T">The type of the data to return.</typeparam>
            <param name="handle">
            A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.
            </param>
            <param name="baseAddress">
            A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all
            data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.
            </param>
            <param name="buffer">A pointer to a buffer that receives the contents from the address space of the specified process.</param>
            <param name="numberOfBytesRead">A pointer to a variable that receives the number of bytes transferred into the specified buffer.</param>
            <returns><see langword="true"/> if the function succeeds; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.ProcessMemory.ReadProcessMemoryArray``1(System.IntPtr,System.IntPtr,``0[])">
            <summary>
            Reads data from an area of memory in a specified process. The entire area to be read must be accessible or the operation fails.
            </summary>
            <typeparam name="T">The type of the data to return.</typeparam>
            <param name="handle">
            A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.
            </param>
            <param name="baseAddress">
            A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all
            data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.
            </param>
            <param name="buffer">A pointer to a buffer that receives the contents from the address space of the specified process.</param>
            <returns><see langword="true"/> if the function succeeds; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.ProcessMemory.ReadProcessMemoryArray``1(System.IntPtr,System.IntPtr,``0[],System.IntPtr@)">
            <summary>
            Reads data from an area of memory in a specified process. The entire area to be read must be accessible or the operation fails.
            </summary>
            <typeparam name="T">The type of the data to return.</typeparam>
            <param name="handle">
            A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.
            </param>
            <param name="baseAddress">
            A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all
            data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.
            </param>
            <param name="buffer">A pointer to a buffer that receives the contents from the address space of the specified process.</param>
            <param name="numberOfBytesRead">A pointer to a variable that receives the number of bytes transferred into the specified buffer.</param>
            <returns><see langword="true"/> if the function succeeds; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.ProcessMemory.ReadProcessMemoryArray``1(System.IntPtr,System.IntPtr,``0[],System.Int32,System.Int32)">
            <summary>
            Reads data from an area of memory in a specified process. The entire area to be read must be accessible or the operation fails.
            </summary>
            <typeparam name="T">The type of the data to return.</typeparam>
            <param name="handle">
            A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.
            </param>
            <param name="baseAddress">
            A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all
            data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.
            </param>
            <param name="buffer">A pointer to a buffer that receives the contents from the address space of the specified process.</param>
            <param name="offset">The offset inside the buffer to read the data to.</param>
            <param name="length">The length of the buffer to fill after the offset.</param>
            <returns><see langword="true"/> if the function succeeds; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.ProcessMemory.ReadProcessMemoryArray``1(System.IntPtr,System.IntPtr,``0[],System.Int32,System.Int32,System.IntPtr@)">
            <summary>
            Reads data from an area of memory in a specified process. The entire area to be read must be accessible or the operation fails.
            </summary>
            <typeparam name="T">The type of the data to return.</typeparam>
            <param name="handle">
            A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.
            </param>
            <param name="baseAddress">
            A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all
            data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.
            </param>
            <param name="buffer">A pointer to a buffer that receives the contents from the address space of the specified process.</param>
            <param name="offset">The offset inside the buffer to read the data to.</param>
            <param name="length">The length of the buffer to fill after the offset.</param>
            <param name="numberOfBytesRead">A pointer to a variable that receives the number of bytes transferred into the specified buffer.</param>
            <returns><see langword="true"/> if the function succeeds; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.ProcessMemory.VirtualAllocEx(System.IntPtr,System.IntPtr,System.IntPtr,ProcessMemoryUtilities.Memory.AllocationType,ProcessMemoryUtilities.Memory.MemoryProtectionFlags)">
            <summary>
            Reserves, commits, or changes the state of a region of memory within the virtual address space of a specified process. The function
            initializes the memory it allocates to zero.
            </summary>
            <param name="handle">
            The handle to a process. The function allocates memory within the virtual address space of this process. The handle must have the
            PROCESS_VM_OPERATION access right.For more information, see Process Security and Access Rights.
            </param>
            <param name="baseAddress">The pointer that specifies a desired starting address for the region of pages that you want to allocate.</param>
            <param name="size">The size of the region of memory to allocate, in bytes.</param>
            <param name="allocationType">The type of memory allocation.</param>
            <param name="memoryProtection">
            The memory protection for the region of pages to be allocated. If the pages are being committed, you can specify any one of the memory
            protection constants.
            </param>
            <returns>
            If the function succeeds, the return value is the base address of the allocated region of pages. If the function fails, the return value is
            NULL.
            </returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.ProcessMemory.VirtualFreeEx(System.IntPtr,System.IntPtr,System.IntPtr,ProcessMemoryUtilities.Memory.FreeType)">
            <summary>
            Releases, decommits, or releases and decommits a region of memory within the virtual address space of a specified process.
            </summary>
            <param name="handle">
            A handle to a process. The function frees memory within the virtual address space of the process. The handle must have the
            PROCESS_VM_OPERATION access right.For more information, see Process Security and Access Rights.
            </param>
            <param name="address">A pointer to the starting address of the region of memory to be freed.</param>
            <param name="size">
            The size of the region of memory to free, in bytes. If the dwFreeType parameter is MEM_RELEASE, dwSize must be 0 (zero).
            </param>
            <param name="freeType">The type of free operation.</param>
            <returns><see langword="true"/> if the function succeeds; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.ProcessMemory.VirtualProtectEx(System.IntPtr,System.IntPtr,System.IntPtr,ProcessMemoryUtilities.Memory.MemoryProtectionFlags,ProcessMemoryUtilities.Memory.MemoryProtectionFlags@)">
            <summary>
            Changes the protection on a region of committed pages in the virtual address space of a specified process.
            </summary>
            <param name="handle">
            A handle to the process whose memory protection is to be changed. The handle must have the PROCESS_VM_OPERATION access right. For more
            information, see Process Security and Access Rights.
            </param>
            <param name="address">A pointer to the base address of the region of pages whose access protection attributes are to be changed.</param>
            <param name="size">The size of the region whose access protection attributes are changed, in bytes.</param>
            <param name="newProtect">The memory protection option. This parameter can be one of the memory protection constants.</param>
            <param name="oldProtect">
            A pointer to a variable that receives the previous access protection of the first page in the specified region of pages.
            </param>
            <returns><see langword="true"/> if the function succeeds; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.ProcessMemory.WaitForSingleObject(System.IntPtr,System.UInt32)">
            <summary>
            Waits until the specified object is in the signaled state or the time-out interval elapses.
            </summary>
            <param name="handle">
            A handle to the object. For a list of the object types whose handles can be specified, see the following Remarks section. If this handle is
            closed while the wait is still pending, the function's behavior is undefined. The handle must have the SYNCHRONIZE access right. For more
            information, see Standard Access Rights.
            </param>
            <param name="timeout">
            The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the object is signaled or the interval
            elapses. If dwMilliseconds is zero, the function does not enter a wait state if the object is not signaled; it always returns immediately.
            If dwMilliseconds is INFINITE, the function will return only when the object is signaled.
            </param>
            <returns>A WaitObjectResult representing the event caused WaitForSingleObject to return.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.ProcessMemory.WriteProcessMemory(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Writes data to an area of memory in a specified process. The entire area to be written to must be accessible or the operation fails.
            </summary>
            <param name="handle">
            A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.
            </param>
            <param name="baseAddress">
            A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all
            data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.
            </param>
            <param name="buffer">A pointer to the buffer that contains data to be written in the address space of the specified process.</param>
            <param name="size">The number of bytes to be written to the specified process.</param>
            <returns><see langword="true"/> if the function succeeds; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.ProcessMemory.WriteProcessMemory(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr@)">
            <summary>
            Writes data to an area of memory in a specified process. The entire area to be written to must be accessible or the operation fails.
            </summary>
            <param name="handle">
            A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.
            </param>
            <param name="baseAddress">
            A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all
            data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.
            </param>
            <param name="buffer">A pointer to the buffer that contains data to be written in the address space of the specified process.</param>
            <param name="size">The number of bytes to be written to the specified process.</param>
            <param name="numberOfBytesWritten">
            A pointer to a variable that receives the number of bytes transferred into the specified process.
            </param>
            <returns><see langword="true"/> if the function succeeds; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.ProcessMemory.WriteProcessMemory``1(System.IntPtr,System.IntPtr,``0)">
            <summary>
            Writes data to an area of memory in a specified process. The entire area to be written to must be accessible or the operation fails.
            </summary>
            <typeparam name="T">The type of the data to write.</typeparam>
            <param name="handle">
            A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.
            </param>
            <param name="baseAddress">
            A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all
            data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.
            </param>
            <param name="buffer">A pointer to the buffer that contains data to be written in the address space of the specified process.</param>
            <returns><see langword="true"/> if the function succeeds; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.ProcessMemory.WriteProcessMemory``1(System.IntPtr,System.IntPtr,``0,System.IntPtr@)">
            <summary>
            Writes data to an area of memory in a specified process. The entire area to be written to must be accessible or the operation fails.
            </summary>
            <typeparam name="T">The type of the data to write.</typeparam>
            <param name="handle">
            A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.
            </param>
            <param name="baseAddress">
            A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all
            data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.
            </param>
            <param name="buffer">A pointer to the buffer that contains data to be written in the address space of the specified process.</param>
            <param name="numberOfBytesWritten">
            A pointer to a variable that receives the number of bytes transferred into the specified process.
            </param>
            <returns><see langword="true"/> if the function succeeds; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.ProcessMemory.WriteProcessMemoryArray``1(System.IntPtr,System.IntPtr,``0[])">
            <summary>
            Writes data to an area of memory in a specified process. The entire area to be written to must be accessible or the operation fails.
            </summary>
            <typeparam name="T">The type of the data to write.</typeparam>
            <param name="handle">
            A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.
            </param>
            <param name="baseAddress">
            A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all
            data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.
            </param>
            <param name="buffer">A pointer to the buffer that contains data to be written in the address space of the specified process.</param>
            <returns>A pointer to a variable that receives the number of bytes transferred into the specified process.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.ProcessMemory.WriteProcessMemoryArray``1(System.IntPtr,System.IntPtr,``0[],System.IntPtr@)">
            <summary>
            Writes data to an area of memory in a specified process. The entire area to be written to must be accessible or the operation fails.
            </summary>
            <typeparam name="T">The type of the data to write.</typeparam>
            <param name="handle">
            A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.
            </param>
            <param name="baseAddress">
            A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all
            data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.
            </param>
            <param name="buffer">A pointer to the buffer that contains data to be written in the address space of the specified process.</param>
            <param name="numberOfBytesWritten">
            A pointer to a variable that receives the number of bytes transferred into the specified process.
            </param>
            <returns><see langword="true"/> if the function succeeds; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.ProcessMemory.WriteProcessMemoryArray``1(System.IntPtr,System.IntPtr,``0[],System.Int32,System.Int32)">
            <summary>
            Writes data to an area of memory in a specified process. The entire area to be written to must be accessible or the operation fails.
            </summary>
            <typeparam name="T">The type of the data to write.</typeparam>
            <param name="handle">
            A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.
            </param>
            <param name="baseAddress">
            A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all
            data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.
            </param>
            <param name="buffer">A pointer to the buffer that contains data to be written in the address space of the specified process.</param>
            <param name="offset">The start offset in the buffer array to write data from.</param>
            <param name="length">The length of the the buffer to write starting from the offset.</param>
            <returns><see langword="true"/> if the function succeeds; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.ProcessMemory.WriteProcessMemoryArray``1(System.IntPtr,System.IntPtr,``0[],System.Int32,System.Int32,System.IntPtr@)">
            <summary>
            Writes data to an area of memory in a specified process. The entire area to be written to must be accessible or the operation fails.
            </summary>
            <typeparam name="T">The type of the data to write.</typeparam>
            <param name="handle">
            A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION access to the process.
            </param>
            <param name="baseAddress">
            A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all
            data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.
            </param>
            <param name="buffer">A pointer to the buffer that contains data to be written in the address space of the specified process.</param>
            <param name="offset">The start offset in the buffer array to write data from.</param>
            <param name="length">The length of the the buffer to write starting from the offset.</param>
            <param name="numberOfBytesWritten">
            A pointer to a variable that receives the number of bytes transferred into the specified process.
            </param>
            <returns><see langword="true"/> if the function succeeds; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="T:ProcessMemoryUtilities.Memory.AllocationType">
            <summary>
            Defines the different types of memory allocations.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.AllocationType.Commit">
            <summary>
            Allocates memory charges (from the overall size of memory and the paging files on disk) for the specified reserved memory pages. The
            function also guarantees that when the caller later initially accesses the memory, the contents will be zero. Actual physical pages are not
            allocated unless/until the virtual addresses are actually accessed. To reserve and commit pages in one step, call VirtualAllocEx with
            MEM_COMMIT | MEM_RESERVE. Attempting to commit a specific address range by specifying MEM_COMMIT without MEM_RESERVE and a non-NULL
            lpAddress fails unless the entire range has already been reserved. The resulting error code is ERROR_INVALID_ADDRESS. An attempt to commit
            a page that is already committed does not cause the function to fail. This means that you can commit pages without first determining the
            current commitment state of each page. If lpAddress specifies an address within an enclave, flAllocationType must be MEM_COMMIT.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.AllocationType.Reserve">
            <summary>
            Reserves a range of the process's virtual address space without allocating any actual physical storage in memory or in the paging file on
            disk. You commit reserved pages by calling VirtualAllocEx again with MEM_COMMIT. To reserve and commit pages in one step, call
            VirtualAllocEx with MEM_COMMIT | MEM_RESERVE. Other memory allocation functions, such as malloc and LocalAlloc, cannot use reserved memory
            until it has been released.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.AllocationType.Reset">
            <summary>
            Indicates that data in the memory range specified by lpAddress and dwSize is no longer of interest. The pages should not be read from or
            written to the paging file. However, the memory block will be used again later, so it should not be decommitted. This value cannot be used
            with any other value. Using this value does not guarantee that the range operated on with MEM_RESET will contain zeros. If you want the
            range to contain zeros, decommit the memory and then recommit it. When you use MEM_RESET, the VirtualAllocEx function ignores the value of
            fProtect. However, you must still set fProtect to a valid protection value, such as PAGE_NOACCESS. VirtualAllocEx returns an error if you
            use MEM_RESET and the range of memory is mapped to a file. A shared view is only acceptable if it is mapped to a paging file.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.AllocationType.Physical">
            <summary>
            Reserves an address range that can be used to map Address Windowing Extensions (AWE) pages. This value must be used with MEM_RESERVE and no
            other values.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.AllocationType.TopDown">
            <summary>
            Allocates memory at the highest possible address. This can be slower than regular allocations, especially when there are many allocations.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.AllocationType.WriteWatch">
            <summary>
            Causes the system to track pages that are written to in the allocated region. If you specify this value, you must also specify MEM_RESERVE.
            To retrieve the addresses of the pages that have been written to since the region was allocated or the write-tracking state was reset, call
            the GetWriteWatch function. To reset the write-tracking state, call GetWriteWatch or ResetWriteWatch. The write-tracking feature remains
            enabled for the memory region until the region is freed.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.AllocationType.ResetUndo">
            <summary>
            MEM_RESET_UNDO should only be called on an address range to which MEM_RESET was successfully applied earlier. It indicates that the data in
            the specified memory range specified by lpAddress and dwSize is of interest to the caller and attempts to reverse the effects of MEM_RESET.
            If the function succeeds, that means all data in the specified address range is intact. If the function fails, at least some of the data in
            the address range has been replaced with zeroes. This value cannot be used with any other value. If MEM_RESET_UNDO is called on an address
            range which was not MEM_RESET earlier, the behavior is undefined. When you specify MEM_RESET, the VirtualAllocEx function ignores the value
            of flProtect. However, you must still set flProtect to a valid protection value, such as PAGE_NOACCESS. Windows Server 2008 R2, Windows 7,
            Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP: The MEM_RESET_UNDO flag is not supported until Windows 8 and
            Windows Server 2012.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.AllocationType.LargePages">
            <summary>
            Allocates memory using large page support. The size and alignment must be a multiple of the large-page minimum. To obtain this value, use
            the GetLargePageMinimum function. If you specify this value, you must also specify MEM_RESERVE and MEM_COMMIT.
            </summary>
        </member>
        <member name="T:ProcessMemoryUtilities.Memory.FreeType">
            <summary>
            Defines the different types of free operations.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.FreeType.CoalescePlaceholders">
            <summary>
            To coalesce two adjacent placeholders, specify MEM_RELEASE | MEM_COALESCE_PLACEHOLDERS. When you coalesce placeholders, lpAddress and
            dwSize must exactly match those of the placeholder.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.FreeType.PreservePlaceholder">
            <summary>
            Frees an allocation back to a placeholder (after you've replaced a placeholder with a private allocation using VirtualAlloc2 or
            Virtual2AllocFromApp). To split a placeholder into two placeholders, specify MEM_RELEASE | MEM_PRESERVE_PLACEHOLDER.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.FreeType.Decommit">
            <summary>
            Decommits the specified region of committed pages. After the operation, the pages are in the reserved state. The function does not fail if
            you attempt to decommit an uncommitted page. This means that you can decommit a range of pages without first determining their current
            commitment state. Do not use this value with MEM_RELEASE. The MEM_DECOMMIT value is not supported when the lpAddress parameter provides the
            base address for an enclave.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.FreeType.Release">
            <summary>
            Releases the specified region of pages, or placeholder (for a placeholder, the address space is released and available for other
            allocations). After the operation, the pages are in the free state. If you specify this value, dwSize must be 0 (zero), and lpAddress must
            point to the base address returned by the VirtualAllocEx function when the region is reserved. The function fails if either of these
            conditions is not met. If any pages in the region are committed currently, the function first decommits, and then releases them. The
            function does not fail if you attempt to release pages that are in different states, some reserved and some committed. This means that you
            can release a range of pages without first determining the current commitment state. Do not use this value with MEM_DECOMMIT.
            </summary>
        </member>
        <member name="T:ProcessMemoryUtilities.Memory.MemoryProtectionFlags">
            <summary>
            Defines the memory protection constants.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.MemoryProtectionFlags.Execute">
            <summary>
            Enables execute access to the committed region of pages. An attempt to write to the committed region results in an access violation. This
            flag is not supported by the CreateFileMapping function.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.MemoryProtectionFlags.ExecuteRead">
            <summary>
            Enables execute or read-only access to the committed region of pages. An attempt to write to the committed region results in an access
            violation. Windows Server 2003 and Windows XP: This attribute is not supported by the CreateFileMapping function until Windows XP with SP2
            and Windows Server 2003 with SP1.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.MemoryProtectionFlags.ExecuteReadWrite">
            <summary>
            Enables execute, read-only, or read/write access to the committed region of pages. Windows Server 2003 and Windows XP: This attribute is
            not supported by the CreateFileMapping function until Windows XP with SP2 and Windows Server 2003 with SP1.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.MemoryProtectionFlags.ExecuteWriteCopy">
            <summary>
            Enables execute, read-only, or copy-on-write access to a mapped view of a file mapping object. An attempt to write to a committed
            copy-on-write page results in a private copy of the page being made for the process. The private page is marked as PAGE_EXECUTE_READWRITE,
            and the change is written to the new page. This flag is not supported by the VirtualAlloc or VirtualAllocEx functions. Windows Vista,
            Windows Server 2003 and Windows XP: This attribute is not supported by the CreateFileMapping function until Windows Vista with SP1 and
            Windows Server 2008.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.MemoryProtectionFlags.NoAccess">
            <summary>
            Disables all access to the committed region of pages. An attempt to read from, write to, or execute the committed region results in an
            access violation. This flag is not supported by the CreateFileMapping function.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.MemoryProtectionFlags.ReadOnly">
            <summary>
            Enables read-only access to the committed region of pages. An attempt to write to the committed region results in an access violation. If
            Data Execution Prevention is enabled, an attempt to execute code in the committed region results in an access violation.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.MemoryProtectionFlags.ReadWrite">
            <summary>
            Enables read-only or read/write access to the committed region of pages. If Data Execution Prevention is enabled, attempting to execute
            code in the committed region results in an access violation.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.MemoryProtectionFlags.WriteCopy">
            <summary>
            Enables read-only or copy-on-write access to a mapped view of a file mapping object. An attempt to write to a committed copy-on-write page
            results in a private copy of the page being made for the process. The private page is marked as PAGE_READWRITE, and the change is written
            to the new page. If Data Execution Prevention is enabled, attempting to execute code in the committed region results in an access
            violation. This flag is not supported by the VirtualAlloc or VirtualAllocEx functions.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.MemoryProtectionFlags.GuardModifierflag">
            <summary>
            Pages in the region become guard pages. Any attempt to access a guard page causes the system to raise a STATUS_GUARD_PAGE_VIOLATION
            exception and turn off the guard page status. Guard pages thus act as a one-time access alarm. For more information, see Creating Guard
            Pages. When an access attempt leads the system to turn off guard page status, the underlying page protection takes over. If a guard page
            exception occurs during a system service, the service typically returns a failure status indicator. This value cannot be used with
            PAGE_NOACCESS. This flag is not supported by the CreateFileMapping function.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.MemoryProtectionFlags.NoCacheModifierflag">
            <summary>
            Sets all pages to be non-cachable. Applications should not use this attribute except when explicitly required for a device. Using the
            interlocked functions with memory that is mapped with SEC_NOCACHE can result in an EXCEPTION_ILLEGAL_INSTRUCTION exception. The
            PAGE_NOCACHE flag cannot be used with the PAGE_GUARD, PAGE_NOACCESS, or PAGE_WRITECOMBINE flags. The PAGE_NOCACHE flag can be used only
            when allocating private memory with the VirtualAlloc, VirtualAllocEx, or VirtualAllocExNuma functions. To enable non-cached memory access
            for shared memory, specify the SEC_NOCACHE flag when calling the CreateFileMapping function.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.MemoryProtectionFlags.WriteCombineModifierflag">
            <summary>
            Sets all pages to be write-combined. Applications should not use this attribute except when explicitly required for a device. Using the
            interlocked functions with memory that is mapped as write-combined can result in an EXCEPTION_ILLEGAL_INSTRUCTION exception. The
            PAGE_WRITECOMBINE flag cannot be specified with the PAGE_NOACCESS, PAGE_GUARD, and PAGE_NOCACHE flags. The PAGE_WRITECOMBINE flag can be
            used only when allocating private memory with the VirtualAlloc, VirtualAllocEx, or VirtualAllocExNuma functions. To enable write-combined
            memory access for shared memory, specify the SEC_WRITECOMBINE flag when calling the CreateFileMapping function. Windows Server 2003 and
            Windows XP: This flag is not supported until Windows Server 2003 with SP1.
            </summary>
        </member>
        <member name="T:ProcessMemoryUtilities.Memory.ProcessAccessFlags">
            <summary>
            Defines process security and access rights.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.ProcessAccessFlags.All">
            <summary>
            All possible access rights for a process object.Windows Server 2003 and Windows XP: The size of the PROCESS_ALL_ACCESS flag increased on
            Windows Server 2008 and Windows Vista. If an application compiled for Windows Server 2008 and Windows Vista is run on Windows Server 2003
            or Windows XP, the PROCESS_ALL_ACCESS flag is too large and the function specifying this flag fails with ERROR_ACCESS_DENIED. To avoid this
            problem, specify the minimum set of access rights required for the operation. If PROCESS_ALL_ACCESS must be used, set _WIN32_WINNT to the
            minimum operating system targeted by your application (for example, #define _WIN32_WINNT _WIN32_WINNT_WINXP). For more information, see
            Using the Windows Headers.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.ProcessAccessFlags.Terminate">
            <summary>
            Required to terminate a process using TerminateProcess.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.ProcessAccessFlags.CreateThread">
            <summary>
            Required to create a thread.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.ProcessAccessFlags.VirtualMemoryOperation">
            <summary>
            Required to perform an operation on the address space of a process (see VirtualProtectEx and WriteProcessMemory).
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.ProcessAccessFlags.VirtualMemoryRead">
            <summary>
            Required to read memory in a process using ReadProcessMemory.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.ProcessAccessFlags.VirtualMemoryWrite">
            <summary>
            Required to write to memory in a process using WriteProcessMemory.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.ProcessAccessFlags.DuplicateHandle">
            <summary>
            Required to duplicate a handle using DuplicateHandle.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.ProcessAccessFlags.CreateProcess">
            <summary>
            Required to create a process.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.ProcessAccessFlags.SetQuota">
            <summary>
            Required to set memory limits using SetProcessWorkingSetSize.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.ProcessAccessFlags.SetInformation">
            <summary>
            Required to set certain information about a process, such as its priority class (see SetPriorityClass).
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.ProcessAccessFlags.QueryInformation">
            <summary>
            Required to retrieve certain information about a process, such as its token, exit code, and priority class (see OpenProcessToken).
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.ProcessAccessFlags.SuspendResume">
            <summary>
            Required to set memory limits using SetProcessWorkingSetSize.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.ProcessAccessFlags.QueryLimitedInformation">
            <summary>
            Required to retrieve certain information about a process (see GetExitCodeProcess, GetPriorityClass, IsProcessInJob,
            QueryFullProcessImageName). A handle that has the PROCESS_QUERY_INFORMATION access right is automatically granted
            PROCESS_QUERY_LIMITED_INFORMATION.Windows Server 2003 and Windows XP: This access right is not supported.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.ProcessAccessFlags.Synchronize">
            <summary>
            Required to wait for the process to terminate using the wait functions.
            </summary>
        </member>
        <member name="T:ProcessMemoryUtilities.Memory.ThreadCreationFlags">
            <summary>
            Defines flags that control the creation of a remote thread.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.ThreadCreationFlags.Immediately">
            <summary>
            The thread runs immediately after creation.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.ThreadCreationFlags.Suspended">
            <summary>
            The thread is created in a suspended state and does not run until the ResumeThread function is called.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.ThreadCreationFlags.StackSizeParamIsAReservation">
            <summary>
            The dwStackSize parameter specifies the initial reserve size of the stack. If this flag is not specified, dwStackSize specifies the commit
            size.
            </summary>
        </member>
        <member name="T:ProcessMemoryUtilities.Memory.WaitObjectResult">
            <summary>
            Defines the events that cause a function like WaitForSingleObject to return.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.WaitObjectResult.Abandoned">
            <summary>
            The specified object is a mutex object that was not released by the thread that owned the mutex object before the owning thread terminated.
            Ownership of the mutex object is granted to the calling thread and the mutex state is set to nonsignaled. If the mutex was protecting
            persistent state information, you should check it for consistency.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.WaitObjectResult.Success">
            <summary>
            The state of the specified object is signaled.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.WaitObjectResult.Timeout">
            <summary>
            The time-out interval elapsed, and the object's state is nonsignaled.
            </summary>
        </member>
        <member name="F:ProcessMemoryUtilities.Memory.WaitObjectResult.Failed">
            <summary>
            The function has failed. To get extended error information, call GetLastError.
            </summary>
        </member>
        <member name="T:ProcessMemoryUtilities.Memory.StaticArrayPool`1">
            <summary>
            Provides a generic, thread safe and static implementation of a pool of arrays.
            </summary>
            <typeparam name="T">The type of the array.</typeparam>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.StaticArrayPool`1.Fill(`0[],System.Boolean)">
            <summary>
            Adds an already allocated array to the StaticArrayPool.
            </summary>
            <param name="array">The array to add.</param>
            <param name="clearArray">Indicates whether the values in the array should be cleared before adding it.</param>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.StaticArrayPool`1.FillSequence(System.Collections.Generic.IEnumerable{`0[]},System.Boolean)">
            <summary>
            Adds a sequence of arrays to the StaticArrayPool.
            </summary>
            <param name="sequence">A sequence of arrays.</param>
            <param name="clearArray">Indicates whether the values of each array should be cleared before adding it.</param>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.StaticArrayPool`1.Rent(System.Int32)">
            <summary>
            Retrieves a buffer the requested length.
            </summary>
            <param name="size">The length of the requested buffer.</param>
            <returns>An array from the StaticArrayPool.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.StaticArrayPool`1.Return(`0[],System.Boolean)">
            <summary>
            Returns a previously rented array to the StaticArrayPool.
            </summary>
            <param name="array">The array to return.</param>
            <param name="clearArray">Indicates whether the values of the array should be cleared before returning it.</param>
        </member>
        <member name="T:ProcessMemoryUtilities.Memory.StringMarshal">
            <summary>
            Provides methods to convert between byte arrays and strings using different encodings.
            </summary>
        </member>
        <member name="P:ProcessMemoryUtilities.Memory.StringMarshal.AppendNullCharacters">
            <summary>
            Determines whether null chars should be added to the end of the output of StringToBytes.
            </summary>
        </member>
        <member name="P:ProcessMemoryUtilities.Memory.StringMarshal.DefaultEncoding">
            <summary>
            Gets or sets the default encoding used by the methods in this class if no encoding got specified.
            </summary>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.StringMarshal.BytesToString(System.Byte[],System.Text.Encoding)">
            <summary>
            Converts a byte array into a string using the default encoding if none is specified.
            </summary>
            <param name="bytes">The byte array to convert.</param>
            <param name="encoding">The encoding to use. null if the default encoding should be used.</param>
            <returns>The string resulting by decoding the bytes in the given byte array.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.StringMarshal.StringToBytes(System.String,System.Text.Encoding)">
            <summary>
            Converts a string into a byte array using the default encoding if none is specified.
            </summary>
            <param name="value">The string to encode.</param>
            <param name="encoding">The encoding to use. null if the default encoding should be used.</param>
            <returns>A byte array representing the encoded characters of the given string.</returns>
        </member>
        <member name="T:ProcessMemoryUtilities.Memory.UnsafeMarshal">
            <summary>
            Provides methods to work with unmanaged memory.
            </summary>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.UnsafeMarshal.Allocate``1">
            <summary>
            Allocates a new value type.
            </summary>
            <typeparam name="T">The type of the object to allocate.</typeparam>
            <returns>The allocated object.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.UnsafeMarshal.AllocateArray``1(System.Int32)">
            <summary>
            Allocates a new array of value types.
            </summary>
            <typeparam name="T">The type of the objects inside the array.</typeparam>
            <param name="length">The length of the array to allocate.</param>
            <returns>The allocated array.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.UnsafeMarshal.AllocateNonZero``1">
            <summary>
            Allocates a new value type without zeroing its memory.
            </summary>
            <typeparam name="T">The type of the object to allocate.</typeparam>
            <returns>The allocated object.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.UnsafeMarshal.AsPointer``1(``0@)">
            <summary>
            Returns a pointer to the given by-ref parameter.
            </summary>
            <typeparam name="T">The type of object.</typeparam>
            <param name="value">The object whose pointer is obtained.</param>
            <returns>A pointer to the given value.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.UnsafeMarshal.Copy(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            Copies bytes from the source address to the destination address.
            </summary>
            <param name="source">The source address to copy from.</param>
            <param name="destination">The destination address to copy to.</param>
            <param name="length">The number of bytes to copy.</param>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.UnsafeMarshal.Copy``1(System.IntPtr,``0@)">
            <summary>
            Copies a value of type <typeparamref name="T">T</typeparamref> to the given location.
            </summary>
            <typeparam name="T">The type of value to copy.</typeparam>
            <param name="source">A pointer to the value to copy.</param>
            <param name="destination">The location to copy to.</param>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.UnsafeMarshal.Copy``1(``0@,System.IntPtr)">
            <summary>
            Copies a value of type <typeparamref name="T">T</typeparamref> to the given location.
            </summary>
            <typeparam name="T">The type of value to copy.</typeparam>
            <param name="source">A pointer to the value to copy.</param>
            <param name="destination">The location to copy to.</param>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.UnsafeMarshal.CopyArray``1(System.IntPtr,``0[])">
            <summary>
            Copies the bytes from source into the destination array.
            </summary>
            <typeparam name="T">The type of the array.</typeparam>
            <param name="source">A pointer to the bytes to copy.</param>
            <param name="destination">The location to copy to.</param>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.UnsafeMarshal.CopyArray``1(``0[],System.IntPtr)">
            <summary>
            Copies the bytes from the source array to the destination buffer.
            </summary>
            <typeparam name="T">The type of the array.</typeparam>
            <param name="source">The array to copy from.</param>
            <param name="destination">The location to copy to.</param>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.UnsafeMarshal.Read``1(System.IntPtr)">
            <summary>
            Reads a value of type <typeparamref name="T">T</typeparamref> from the given location.
            </summary>
            <typeparam name="T">The type to read.</typeparam>
            <param name="address">The location to read from.</param>
            <returns>An object of type <typeparamref name="T">T</typeparamref> read from the given location.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.UnsafeMarshal.Read``1(System.IntPtr,System.Int32)">
            <summary>
            Reads a value of type <typeparamref name="T">T</typeparamref> from the given location.
            </summary>
            <typeparam name="T">The type to read.</typeparam>
            <param name="address">The location to read from.</param>
            <param name="offset">The byte offset to add.</param>
            <returns>An object of type <typeparamref name="T">T</typeparamref> read from the given location.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.UnsafeMarshal.Read``1(System.Byte[])">
            <summary>
            Reads a value from the array.
            </summary>
            <typeparam name="T">The type to read.</typeparam>
            <param name="array">The array to read from.</param>
            <returns>An object of type <typeparamref name="T">T</typeparamref> read from the given array.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.UnsafeMarshal.Read``1(System.Byte[],System.Int32)">
            <summary>
            Reads a value from the array.
            </summary>
            <typeparam name="T">The type to read.</typeparam>
            <param name="array">The array to read from.</param>
            <param name="offset">The byte offset to add.</param>
            <returns>An object of type <typeparamref name="T">T</typeparamref> read from the given array.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.UnsafeMarshal.ReinterpretCast``2(``0@)">
            <summary>
            Casts the value of the by-ref parameter from <typeparamref name="TFrom">TFrom</typeparamref> to
            <typeparamref name="TTo">TTo</typeparamref>.
            </summary>
            <typeparam name="TFrom">The initial type of the object.</typeparam>
            <typeparam name="TTo">The type to cast the given by-ref parameter to.</typeparam>
            <param name="value">The original object.</param>
            <returns>The value of the by-ref parameter reinterpreted as another type.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.UnsafeMarshal.SizeOf``1">
            <summary>
            Returns the size of an object of the given type parameter.
            </summary>
            <typeparam name="T">The type of object whose size is retrieved.</typeparam>
            <returns>The size of an object of type <typeparamref name="T">T</typeparamref>.</returns>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.UnsafeMarshal.Write``1(System.IntPtr,``0)">
            <summary>
            Writes a value of type <typeparamref name="T">T</typeparamref> to the given location.
            </summary>
            <typeparam name="T">The type of value to write.</typeparam>
            <param name="address">The location to write to.</param>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.UnsafeMarshal.Write``1(System.IntPtr,System.Int32,``0)">
            <summary>
            Writes a value of type <typeparamref name="T">T</typeparamref> to the given location.
            </summary>
            <typeparam name="T">The type of value to write.</typeparam>
            <param name="address">The location to write to.</param>
            <param name="offset">The byte offset to add to the address.</param>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.UnsafeMarshal.Write``1(System.Byte[],``0)">
            <summary>
            Writes a value of type <typeparamref name="T">T</typeparamref> to the given location.
            </summary>
            <typeparam name="T">The type of value to write.</typeparam>
            <param name="buffer">The buffer to be written.</param>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.UnsafeMarshal.Write``1(System.Byte[],System.Int32,``0)">
            <summary>
            Writes a value of type <typeparamref name="T">T</typeparamref> to the given location.
            </summary>
            <typeparam name="T">The type of value to write.</typeparam>
            <param name="buffer">The buffer to be written.</param>
            <param name="offset">The byte offset inside the buffer.</param>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.UnsafeMarshal.ZeroArray``1(``0[])">
            <summary>
            Initializes the values in the given array to zero.
            </summary>
            <typeparam name="T">The type of the array.</typeparam>
            <param name="array">The array that should be initialized to zero.</param>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.UnsafeMarshal.ZeroMemory(System.IntPtr,System.Int32)">
            <summary>
            Initializes a block of memory at the given address to zero.
            </summary>
            <param name="address">The location of the memory.</param>
            <param name="length">The length of the block in bytes.</param>
        </member>
        <member name="M:ProcessMemoryUtilities.Memory.UnsafeMarshal.ZeroMemory``1(``0@)">
            <summary>
            Initializes the by-ref parameter to zero.
            </summary>
            <typeparam name="T">The type of the object.</typeparam>
            <param name="value">A reference to an object.</param>
        </member>
    </members>
</doc>
